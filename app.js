// Generated by CoffeeScript 1.3.3
var DDBB, DEBUG, HOSTS, app, createHash, crypto, env, express, feed, generateMongoUrl, getParser, jstoxml, loadParser, mongo, mongodb, mongoose, parsers, rss, rssSchema, url;

express = require('express');

url = require('url');

crypto = require('crypto');

mongoose = require('mongoose');

jstoxml = require('jstoxml');

app = express();

parsers = require("./parsers");

HOSTS = require('./hosts');

DEBUG = true;

if (process.env.VCAP_SERVICES) {
  env = JSON.parse(process.env.VCAP_SERVICES);
  mongo = env['mongodb-1.8'][0]['credentials'];
} else {
  mongo = {
    "hostname": "localhost",
    "port": 27017,
    "username": "",
    "password": "",
    "name": "",
    "db": "db"
  };
}

generateMongoUrl = function(_object) {
  _object.hostname = _object.hostname || 'localhost';
  _object.port = _object.port || 27017;
  _object.db = _object.db || 'test';
  if (_object.username && _object.password) {
    return "mongodb://" + _object.username + ":" + _object.password + "@" + _object.hostname + ":" + _object.port + "/" + _object.db;
  } else {
    return "mongodb://" + _object.hostname + ":" + _object.port + "/" + _object.db;
  }
};

DDBB = {
  collection: 'rss',
  connection: generateMongoUrl(mongo)
};

mongodb = mongoose.createConnection(DDBB.connection);

mongodb.on('error', console.error.bind(console, 'connection error: '));

feed = (function() {

  function feed() {}

  feed.prototype.contructor = function(json, xml, base) {
    this.json = json != null ? json : "";
    this.xml = xml != null ? xml : "";
    this.base = base != null ? base : "";
  };

  feed.prototype.init = function(_title, _link, _original, _pubDate) {
    this.xml = '';
    return this.json = {
      _name: 'rss',
      _attrs: {
        version: '2.0'
      },
      _content: {
        channel: [
          {
            title: _title
          }, {
            pubDate: _pubDate
          }, {
            original: _original
          }, {
            link: _link
          }
        ]
      }
    };
  };

  feed.prototype.addItem = function(_item) {
    return this.json._content.channel.push(_item);
  };

  feed.prototype.addItems = function(_items) {
    var item, _i, _len, _results;
    _results = [];
    for (_i = 0, _len = _items.length; _i < _len; _i++) {
      item = _items[_i];
      _results.push(this.addItem(item));
    }
    return _results;
  };

  feed.prototype.getXML = function() {
    return this.xml = jstoxml.toXML(this.json, {
      header: true,
      indent: '  '
    });
  };

  return feed;

})();

rssSchema = new mongoose.Schema({
  hash: {
    type: String,
    index: true
  },
  parser: {
    type: String,
    "default": 'default'
  },
  url: String,
  added: {
    type: Date,
    "default": Date.now
  },
  custom_url: String
}, {
  collection: 'rss'
});

getParser = function(_url) {
  var host, parser;
  parser = 'default';
  host = url.parse(_url).host.replace("/", "").replace("www.", "");
  if (HOSTS[host] != null) {
    parser = HOSTS[host];
  }
  return parser;
};

createHash = function(_url, _parser) {
  var hash;
  hash = crypto.createHash('md5');
  return hash.update(_url + _parser).digest('hex');
};

rss = mongodb.model('rss', rssSchema);

loadParser = function(_parser) {
  if (_parser == null) {
    _parser = "default";
  }
  if (parsers[_parser]) {
    return new parsers[_parser]();
  } else {
    return null;
  }
};

app.use(express.bodyParser());

app.get("/", function(request, response) {
  return response.sendfile("public/home.html");
});

app.use("/static", express["static"](__dirname + '/public/static'));

app.post("/", function(request, response) {
  var hash, parser, rssUrl;
  rssUrl = request.param('rss');
  parser = getParser(rssUrl);
  hash = createHash(rssUrl, parser);
  return rss.findOne({
    hash: hash
  }, function(_error, _item) {
    var item;
    if (_item !== null) {
      return response.redirect("/" + _item.hash + ".xml");
    } else {
      item = new rss({
        url: rssUrl,
        hash: hash,
        parser: parser
      });
      return item.save(function() {
        return response.redirect("/" + item.hash + ".xml");
      });
    }
  });
});

app.get("/:hash.xml", function(request, response) {
  var hash, item;
  hash = request.params.hash;
  return item = rss.findOne({
    $or: [
      {
        custom_url: hash
      }, {
        hash: hash
      }
    ]
  }, function(_error, _item) {
    var itemParser;
    if (_item === null) {
      response.set('Content-Type', 'text/html');
      response.status(404);
      return response.sendfile('public/404.html');
    } else {
      itemParser = loadParser(_item.parser);
      return itemParser.work(_item.url, function(items) {
        var responseFeed;
        responseFeed = new feed();
        responseFeed.init('Title', "http://localhost:3000/" + hash + ".xml", 'Original', 'PubDate');
        responseFeed.addItems(items);
        response.set('Content-Type', 'application/rss+xml');
        return response.send(responseFeed.getXML());
      });
    }
  });
});

app.listen(process.env.VCAP_APP_PORT || 3000);
